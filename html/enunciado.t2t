Algoritmos e Estrutura de Dados I - Trabalho 1
... e as coisas começam a ficar #divertidas

%txt2tags --style css/novo.css -t html index.t2t
%!includeconf: bootstrap/config.t2t
%%!includeconf: aed1_cfg.t2t
%!include(html): bootstrap/menu.t2t

{{DIV ID="toc"}}
%%toc
{{/DIV ID="toc"}}
{{DIV CLASS="testimonial" ID="testimonial"}}
	Que #trabalho1 #divertido. #GO #AED1
{{/DIV}}
{{DIV CLASS="content"}}

    | {{H2}} DUCKTER - AED22CP - 2016/2{{/H2}}
    |    //Bruno César Ribas//
    |    //Notória ajuda de Cristian Pastro e Marcus Antunius//
    |       {{div align=right class="fb-like" data-href="ENDERECO" data-send="false" data-show-faces="true"}}{{/div}}


=Prólogo=

O mundo não é mais como antigamente. As notícias, agora, são lidas pelo
computador e ordenadas de acordo com algum algoritmo que identifica o que é
de maior interesse para algum grupo de usuário.

Antigamente as notícias eram lidas em jornais impressos que eram gerados no
dia anterior. Em resumo, líamos notícias defasadas mas podíamos decidir por
nossa conta qual notícia achávamos mais pertinente para o nosso dia.

 [lendo-jornal.jpg]

O mecanismo de utilização de um algoritmo para a escolha de notícias é muito
bacana se não pensarmos muito a respeito, afinal você abre o endereço de
notícias e consegue ler o que te interesse, ou ao menos o que você acha que
te interessa.

O que percebemos ao longo do tempo é que esses algoritmos tendem a criar uma
bolha de notícias. Você acaba ficando preso em uma escolha algorítmica que
não permite que você saia. Muitos estudos e até livros foram feitos sobre
isso, veja [aqui https://www.amazon.com/Filter-Bubble-Personalized-Changing-Think/dp/0143121235?tag=duckduckgo-d-20]
, [aqui também http://fortune.com/2016/05/12/facebook-and-the-news/],
e [outra vez aqui https://digdipblog.com/tag/algorithmic-bubbles/].

==A busca da salvação==

Sabendo de todo esse problema, a empresa mais ética do país - Agrupamento
Ético de Dados Duck Duck Computação Diversificada, ou simplesmente AED22CP,
convidou você, um nobre programador e pensador algorítmico para desenvolver
uma solução de busca e //tageamento//.

A AED22CP entende muito bem o problema de bolha algorítmica e precisa de sua
ajuda para conseguir realizar operações com o grande site de notícias
micro-bloging, o duckter.

 [duckter.png]

O duckter possui um volume de milhares de operações por dia. Algumas dessas
operações são:
 - Adicionar uma CHAVE única com um conteúdo específico;
 - Receber um HIT de uma #TAG que aponta para uma chave;
 - Buscar as #TAGS e CHAVES mais consultadas e criar uma página de
   //trending topic//.



Agora vamos detalhar mais o que são as operações que você deverá fazer.


=A entrada de dados=

Como dito anteriormente, a AED22CP é muito ética e por isso você não terá
acesso ao conteúdo completo do duckter.

O seu programa irá processar as informações ao longo dos dias, e não será
encerrado a cada troca dia, mas receberá a informação de que um dia passou.

A entrada dos dados será feita por meio de comandos. Os comandos são:

- **add key CHAVE: conteudo**

exemplo:
```
add key teste: o dia tem um belo azul no horizonte
```
 - CHAVE:  é a chave que será adicionada, máximo de 50 caracteres
 - conteúdo: é o conteúdo que a chave está indexando, máximo de 1000
   caracteres.

- **tag hit #tag chave**

exemplo:
```
tag hit #belo teste
```
 - **#tag**: é o nome da tag que foi colocada em algum post.
 - **chave**: é o código da chave que esta tag referencia. Note que este
   comando garante que a tag que a tag hit aponta para uma chave adicionada
   previamente.

- **rm key CHAVE**

exemplo:
```
rm key teste
```

- **rm tag #tag**

exemplo:
```
rm tag #belo
```

- **rm brokentagref**
 - Este é um mecanismo para deixar as listas saudáveis. O comando **rm key**
   pode deixar algumas tags sem referência válida. Se a chave //teste//
   existe e a tag //#belo// aponta para a chave //teste//, depois de remover
   a chave //teste// a tag //#belo// fica sem apontador e com o comando
   deste item a tag //#belo// deverá ser removida

- **new day**
 - Comando que inicia um novo dia!
 - Note que SEMPRE que seu programa inicia deve ser considerado um novo dia
   sem nenhuma adição
 - Quando recebido o comando **new day** o seu programa deverá remover todas
   as tags que não tiveram hit no dia.

exemplo:
```
add key lindo: um lindo dia comeca hoje
add key etico: AED22CP eh muito etico
tag hit #dia lindo
tag hit #duckter etico
new day
tag hit #dia lindo
new day
```
 - no exemplo acima, adiciona-se as chaves //lindo// e //etico//, e depois
   tem //hit// nas tags //#dia// e //#duckter//, logo ambas as tags possuem 1
   //hit// cada.
 - com o comando **new day**, as tags ficam com seus hits zerados, mas
   permanecem armazenadas
 - //hit// para a tag //#dia//, ficando com 1 hit
 - com o comando **new day**, a tag //#duckter// deve ser removida, pois
   ficou sem //hit// no dia que passou e a tag //#dia// permanesse armazenada
   pois teve um //hit//.

- **rm orphankey**
 - Este comando remove as chaves que não possuem tags as referenciando,
   exemplo:
```
add key teste: um teste de chave
add key orphan: uma chave forever alone
tag hit #maluco teste
rm orphankey
```
  - neste exemplo a chave //orphan// deverá ser removida

- **dump tags**
 - Este comando indica que seu programa deverá imprimir todas as tags
   armazenadas, no formato:
```
formato a definir
```

- **dump keys**
 - Este comando indica que seu programa deverá imprimir todas as keys
   armazenadas, no formato:
```
formato a definir
```

- **show tagcontent #tagid**
 - Este comando busca o conteúdo da chave para qual uma tag aponta, exemplo:
```
add key belo: um belo dia floresce
tag hit #flor belo
show tagcontent #flor
```
 - A saída deverá ser o conteúdo da chave //belo//
```
#flor -> belo
belo :. um belo dia floresce
```

- **list trending top|bottom XX**
 - quando 'top' calcula as XX% tags com mais hits do dia
 - quando 'bottom' calcula as XX% tags com menos hits do dia
 - XX é a porcentagem.
  - ex: 10 representa as top 10% (de todas as tags registradas) com mais
    hits



=Ranking=

O ranking será feito por disputas diárias. Para participar basta enviar o
código que o sistema copilará e executará.

Para participar do Ranking o seu código deve funcionar no UBUNTU dos
laboratórios. Se o sistema não conseguir compilar seu
programa apenas será avisado que não conseguiu e nada mais.

A submissão para o Rank é **Obrigatória**.

No Rank a ordenação será considerada pelo SCORE, definido como:
```
a definir
```

=Prazos=

- O prazo final de submissão é:


=Critérios da Correção=

- O trabalho vale 100 pontos
- Os trabalhos serão executada contra todas as entradas publicadas no rank.
 - O rank definirá 2 limiares definidos como //"Simples"// e //"Super Simples"//
  - Ficando abaixo do //"Super Simples"// o trabalho valerá no máximo 50
    pontos;
  - Ficando entre o //"Simples"// e o //"Super Simples"// o trabalho valerá
    no máximo 80pontos;
 - Se o programa falhar em qualquer entrada terá um desconto de 10 pontos, e
   desconto adicional de 5 pontos por cada entrada que falhar.
    - Se falhar em apenas 1 entrada terá um desconto de 10pontos, se falhar em
      2 entradas o desconto será de 15pontos, em 3 entradas desconto de 20pontos,
      e assim por diante.
 - Se o programa falhar em 50% ou mais das entradas, terá nota automaticamente
   em 0.
- Os programas que não falharem em nenhuma entrada entrarão na rodada especial
  para ponto extra
 - Na rodada especial será executado uma nova entrada
 - Se o programa falhar na rodada especial terá um desconto de 10 pontos
 - Os 3 melhores programas receberão 10 pontos extras.

- Além da rodada automática os trabalhos passarão pelas seguintes
  avaliações:
    - Será considerado o código:
        - Otimização
        - Limpeza do código
        - Criatividade
    - Defesa individual do código quando a T1 - P2 >= 40
     - Lembrando que quando o trabalho for em dupla apresenta quem tiver a
       maior diferença





{{/DIV CLASS="content"}}
%!include(html): bootstrap/footer.t2t
