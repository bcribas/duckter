Algoritmos e Estrutura de Dados I - Trabalho 1 e 2
... e as coisas começam a ficar #divertidas

%txt2tags --style css/novo.css -t html index.t2t
%!includeconf: bootstrap/config.t2t
%%!includeconf: aed1_cfg.t2t
%!include(html): bootstrap/menu.t2t

{{DIV ID="toc"}}
%%toc
{{/DIV ID="toc"}}
{{DIV CLASS="testimonial" ID="testimonial"}}
	Que #trabalho #divertido. #GO #AED1
{{/DIV}}
{{DIV CLASS="content"}}

    | {{H2}} DUCKTER - AED22CP - 2016/2{{/H2}}
    |    //Bruno César Ribas//
    |    //Notória ajuda de Cristian Pastro e Marcus Antunius//
    |       {{div align=right class="fb-like" data-href="ENDERECO" data-send="false" data-show-faces="true"}}{{/div}}


**Atenção** - Este documento ainda se encontra em desenvolvimento.
Atualizações serão constantes.

=Prólogo=

O mundo não é mais como antigamente. As notícias, agora, são lidas pelo
computador e ordenadas de acordo com algum algoritmo que identifica o que é
de maior interesse para algum grupo de usuários.

Antigamente as notícias eram lidas em jornais impressos que eram gerados no
dia anterior. Em resumo, líamos notícias defasadas mas podíamos decidir por
nossa conta qual notícia achávamos mais pertinente para o nosso dia.

 [lendo-jornal.jpg]

O mecanismo de utilização de um algoritmo para a escolha de notícias é muito
bacana se não pensarmos muito a respeito, afinal você abre o endereço de
notícias e consegue ler o que te interesse, ou ao menos o que você acha que
te interessa.

O que percebemos ao longo do tempo é que esses algoritmos tendem a criar uma
bolha de notícias. Você acaba ficando preso em uma escolha algorítmica que
não permite que você saia. Muitos estudos e até livros foram feitos sobre
isso, veja [aqui https://www.amazon.com/Filter-Bubble-Personalized-Changing-Think/dp/0143121235?tag=duckduckgo-d-20]
, [aqui também http://fortune.com/2016/05/12/facebook-and-the-news/],
e [outra vez aqui https://digdipblog.com/tag/algorithmic-bubbles/].

==A busca da salvação==

Sabendo de todo esse problema, a empresa mais ética do país - Agrupamento
Ético de Dados Duck Duck Computação Diversificada, ou simplesmente AED22CP,
convidou você, um nobre programador e pensador algorítmico para desenvolver
uma solução de busca e //tageamento//.

A AED22CP entende muito bem o problema de bolha algorítmica e precisa de sua
ajuda para conseguir realizar operações com o grande site de notícias
micro-bloging, o duckter.

 [duckter.png]

O duckter possui um volume de milhares de operações por dia. Algumas dessas
operações são:
 - Adicionar uma CHAVE única com um conteúdo específico;
 - Receber um HIT de uma #TAG que aponta para uma chave;
 - Buscar as #TAGS e CHAVES mais consultadas e criar uma página de
   //trending topic//.



Agora vamos detalhar mais o que são as operações que você deverá fazer.


=A entrada de dados=

Como dito anteriormente, a AED22CP é muito ética e por isso você não terá
acesso ao conteúdo completo do duckter.

O seu programa irá processar as informações ao longo dos dias, e não será
encerrado a cada troca de dia, mas receberá a informação de que um dia
passou.

Este trabalho foi dividido em duas etapas. A primeira etapa conta como
trabalho 1 e segunda etapa como trabalho 2. Um subconjunto de comandos
deverá ser implementado como parte do trabalho 1.

A etapa 2 depende dos comandos da etapa 1, ou seja, a etapa 2 é um
incremento dos comandos da etapa 1.

A entrada dos dados será feita por meio de comandos. Os comandos são:

===Etapa 1===

====add key CHAVE: conteudo====

exemplo:
```
add key teste: o dia tem um belo azul no horizonte
```
 - CHAVE:  é a chave que será adicionada, máximo de 50 caracteres
 - conteúdo: é o conteúdo que a chave está indexando, máximo de 1000
   caracteres;
 - A quantidade de chaves a serem adicionadas é indeterminada.



====tag hit #tag chave====
 - Atualizado 04/10/2016


exemplo:
```
tag hit #belo teste
```
 - **#tag**: é o nome da tag que foi colocada em algum post, __tamanho máximo__
   __de 1000 caracteres__
 - **chave**: é o código da chave que esta tag referencia. Note que este
   comando garante que a tag que a //tag hit// aponta para uma chave
   adicionada previamente.
 - A quantidade de tags a serem adicionadas é indeterminada.



====show tagcontent #tagid====
 - Este comando busca o conteúdo da chave para qual uma tag aponta, exemplo:
```
add key belo: um belo dia floresce
tag hit #flor belo
show tagcontent #flor
```
 - A saída deverá ser o conteúdo da chave //belo//, como abaixo:
```
#flor -> belo
belo :. um belo dia floresce
```



====list trending top XX====
====list trending bottom XX====
 - quando 'top' calcula as XX% tags com mais hits do dia
 - quando 'bottom' calcula as XX% tags com menos hits do dia
 - XX é a porcentagem.
  - ex: 10 representa as top 10% (de todas as tags registradas) com mais
    hits



====dump tags====
 - Este comando indica que seu programa deverá imprimir todas as tags
   armazenadas, no formato:
```
#tag -> chave :: hits=%d
```

exemplo:
 - entrada
```
add key belo: um belo dia floresce
tag hit #flor belo
tag hit #dia belo
tag hit #dia belo
dump tags
```
 - saída
```
#flor -> belo :: hits=1
#dia -> belo :: hits=2
```



====dump keys====
 - Este comando indica que seu programa deverá imprimir todas as keys
   armazenadas, no formato:
```
chave content="conteudo" refs=%d
```
exemplo:
 - entrada
```
add key belo: um belo dia floresce
add key orange: is the new black
tag hit #flor belo
tag hit #dia belo
tag hit #dia belo
add key maluco: forever alone
tag hit #chato orange
dump tags
```
 - saída
```
belo content="um belo dia floresce" refs=3
orange content="is the new black" refs=1
maluco content="foreve alone" refs=0
```




===Etapa 2===
====rm key CHAVE====

exemplo:
```
rm key teste
```


====rm tag #tag====

exemplo:
```
rm tag #belo
```


====rm brokentagref====
 - Este é um mecanismo para deixar as listas saudáveis. O comando **rm key**
   pode deixar algumas tags sem referência válida. Se a chave //teste//
   existe e a tag //#belo// aponta para a chave //teste//, depois de remover
   a chave //teste// a tag //#belo// fica sem apontador e com o comando
   deste item a tag //#belo// deverá ser removida




====new day====
 - Comando que inicia um novo dia!
 - Note que SEMPRE que seu programa inicia deve ser considerado um novo dia
   sem nenhuma adição
 - Quando recebido o comando **new day** o seu programa deverá remover todas
   as tags que não tiveram hit no dia.

exemplo:
```
add key lindo: um lindo dia comeca hoje
add key etico: AED22CP eh muito etico
tag hit #dia lindo
tag hit #duckter etico
new day
tag hit #dia lindo
new day
```
 - no exemplo acima, adiciona-se as chaves //lindo// e //etico//, e depois
   tem //hit// nas tags //#dia// e //#duckter//, logo ambas as tags possuem 1
   //hit// cada.
 - com o comando **new day**, as tags ficam com seus hits zerados, mas
   permanecem armazenadas
 - //hit// para a tag //#dia//, ficando com 1 hit
 - com o comando **new day**, a tag //#duckter// deve ser removida, pois
   ficou sem //hit// no dia que passou e a tag //#dia// permanecem armazenada
   pois teve um //hit//.




====rm orphankey====
 - Este comando remove as chaves que não possuem tags as referenciando,
   exemplo:
```
add key teste: um teste de chave
add key orphan: uma chave forever alone
tag hit #maluco teste
rm orphankey
```
  - neste exemplo a chave //orphan// deverá ser removida



=Ranking=

O ranking será feito por disputas diárias. Para participar basta enviar o
código que o sistema compilará e executará.

Para participar do Ranking o seu código deve funcionar no UBUNTU dos
laboratórios. Se o sistema não conseguir compilar seu
programa apenas será avisado que não conseguiu e nada mais.

A submissão para o Rank é **Obrigatória**.

No Rank a ordenação será considerada pelo SCORE, definido como:
```
Latencia*10 + Memória Usada em Bytes
```
 - Quanto menor, melhor.



=Prazos=

- Para a ETAPA 1: //6 de Novembro às 23h59//
- Para a ETAPA 2: //10 de Dezembro às 23h59//


=Critérios da Correção=

- Cada etapa vale 100 pontos
- Os trabalhos serão executados contra todas as entradas publicadas no rank.
 - O rank definirá 2 limiares definidos como //"Simples"// e //"Super Simples"//
  - Ficando abaixo do //"Super Simples"// o trabalho valerá no máximo 50
    pontos;
  - Ficando entre o //"Simples"// e o //"Super Simples"// o trabalho valerá
    no máximo 80 pontos;
 - Se o programa falhar em qualquer entrada terá um desconto de 10 pontos, e
   desconto adicional de 5 pontos por cada entrada que falhar.
    - Se falhar em apenas 1 entrada terá um desconto de 10 pontos, se falhar
      em 2 entradas o desconto será de 15 pontos, em 3 entradas desconto de
      20 pontos, e assim por diante.
 - Se o programa falhar em 50% ou mais das entradas, terá nota automaticamente
   em 0.
- Os programas que não falharem em nenhuma entrada entrarão na rodada especial
  para ponto extra
 - Na rodada especial será executado uma nova entrada
 - Se o programa falhar na rodada especial terá um desconto de 10 pontos
 - Os 3 melhores programas receberão 10 pontos extras.

- Além da rodada automática os trabalhos passarão pelas seguintes
  avaliações:
    - Será considerado o código:
        - Otimização
        - Limpeza do código
        - Criatividade
    - Para o aluno ou dupla que **não** fizerem a etapa 1 no prazo, mas
      concluírem a etapa 2, receberão no máximo nota 60 para etapa 1;
    - Defesa individual do código quando a T1 - P2 >= 40 para etapa 1, e
    - Defesa individual do código quando a T2 - P3 >= 40 para etapa 2, e
     - Lembrando que quando o trabalho for em dupla apresenta quem tiver a
       maior diferença





{{/DIV CLASS="content"}}
%!include(html): bootstrap/footer.t2t
